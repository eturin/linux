#include <iostream>
#include <omp.h>

static const unsigned LEN=10;

int main(){
	int p=-1;
	/*параллельная секция*/
	#pragma omp parallel reduction(* : p) num_threads(3) //переменная p размножится на каждый поток, а при выходе вычислит (-1) * 4 * 4 * 4 (т.е. исходное значение, которое было до параллельного блока, умножится на полученный результат в каждом из потоко) ("+", "*", "-", "&", "|", "^", "&&", "||")
	{
		std::cout<<p<<" ("<<omp_get_thread_num()<<") начальное значение зависит от вида агрегатной операции";
		p+=3;
		std::cout<<p<<std::endl;
	}
	std::cout <<"p = "<< p <<std::endl;

	int sum=0;
	/*Цикл распараллелится посчитается сумма в каждом, а потом все суммы сложатся, т.к. указан знак суммы перед двоиточиемб
	 * Здесь не будет гонки за ресурс, т.к. каждый поток будет накапливать свою переменную sum*/
	#pragma omp parallel for reduction(+:sum) num_threads(4)
	for(unsigned i=0;i<LEN;++i){
		sum+=i;
		std::cout <<sum<<std::endl;
	}

	std::cout<<sum<<std::endl;
	
	int c=1;
	/*reduction - создает инициализированную переменную для каждого потока (значение инициализации зависит от агрегатной функции), и в конце параллельной секции значения всех таких переменных прибавится ко внешней переменной*/
	#pragma omp parallel reduction(+:c) num_threads(30)
	{
		c+=1;
	}
	std::cout<<"c = "<<c<<std::endl;

	return 0;
}
