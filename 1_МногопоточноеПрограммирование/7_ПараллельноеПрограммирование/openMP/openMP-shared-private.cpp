#include <iostream>
#include <omp.h>
#include <unistd.h>

int main(){
	/*эта переменная изменится многократно в разных потоках*/
	int aa=0;

	/*Все потоки будут в общей памяти*/
	#pragma omp parallel num_threads(7)
	{
		int i=0;//эта переменная объявлена внутри и будет для каждого потока локальной
		sleep(1);
		++i;

		#pragma omp atomic
		++aa; //эта переменная объявлена снаружи, поэтому ее изменения нужно защитить от непоследовательного доступа
		
		std::cout << omp_get_thread_num() <<")i = "<<i<<" aa = "<<aa<< std::endl;
	}

	/*управление локальностью переменных*/
	int a,b,c,d;
	a=b=c=d=0;
	/*shared(a,b) - переменные a и b станут общими для всех потоков (можно не указывать, т.к. по умолчанию так и будет, за исключением переменных-итераторов циклов)
	  private(c,d) - будут созданы переменные c и d локальные, для каждого потока, начальная их инициализация не производится и обратно значения не копируются
	  Можно явно задать для всех внешних переменных тип использования -  default(private) - так, к примеру, для всех внешних переменных (в каждом потоке породится локальная переменная)
	 */
	#pragma omp parallel num_threads(2) private(c,d)
	{
		sleep(2);

		//эти переменные общие для всех и их изменения нужно упорядочить
		#pragma omp atomic
		++a;
		#pragma omp atomic
		++b;

		//эти переменные в каждом потоке самостоятельные и требуют ИНИЦИАЛИЗАЦИИ!!!! (можно было бы сраз объявлять их внутри, а не с наружи)
		c=3;
		d=3;

		std::cout<< omp_get_thread_num() <<")a = "<<a<<" b = "<<b<<" c = "<<c<<" d = "<<d<<std::endl;
	}	
	std::cout<<"c = "<<c<<", d = "<<d<<std::endl;
	c=1;
	d=2;

	/*firstprivate(c,d) - создаются локальные копии с инициализацией на основе исходных переменных*/
	#pragma omp parallel firstprivate(c,d) num_threads(3)
	{
		std::cout<<"firstprivate(c,d) - инициализировал локальные переменные на основе исходных: c = "<<c<<", d = "<<d<<std::endl;
	}

	/*lastprivate(c,d) - порождаются локальные переменные БЕЗ ИНИЦИАЛИЗАЦИИ и с последнего витка ЦИКЛА (одного из потоков) значение копируется обратно в исходные переменные*/
	#pragma omp parallel for num_threads(100) lastprivate(c,d)
	for(int i=0;i<10;i+=2){
		c=i;
		d=omp_get_thread_num();	
	}
	std::cout<<"lastprivate(c,d) - нет инициализации, но значение переменной становится равной значению с последнего витка цикла(цикл обязателен)  : c = "<<c<<", d = "<<d<<std::endl;

	c=0;
	/*reduction - создает инициализированную переменную для каждого потока (значение инициализации зависит от агрегатной функции), и в конце параллельной секции значения всех таких переменных прибавится ко внешней переменной*/
	#pragma omp parallel reduction(+:c) num_threads(30)
	{
		c+=1;
	}
	std::cout<<"c = "<<c<<std::endl;


	/*copyprivate - копирует значение локальной переменной одного потока в соответствующие локальные переменные остальных потоков*/
	omp_set_num_threads(5); //жестко задаем количество потоков
	#pragma omp parallel
	{
		int a;
		#pragma omp single copyprivate(a) //обязательный барьер в конце (после выхода из блока, переменная a станет одинаковой у всех аотоков)
		a=omp_get_thread_num(); //в переменную записываем номер потока, вошедшего в секцию, которая может быть выполненав только один раз

		std::cout<<"поток - "<<omp_get_thread_num()<<" a = "<<a<<std::endl;//переменная у всех потоков имеет одно и тоже значение
	}
	return 0;
}
