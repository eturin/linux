#include <thread>
#include <iostream>
#include <unistd.h>

void hndl_func(){
	std::cout<<"Запущен\n";
}

void hndl_other_func(int & i,int j){
	i+=j;
}

int main(){
	/*создаем экземпляр класса и он сразу запускает поток*/
	std::thread th1(hndl_func);
	th1.join();//присоединяем поток к основному потоку процесса, т.е. ждем завершения
	//th1.detach();//можно сообщить потоку, что после завершения не ждал присоединения

	/*этот вариант для функции принимающей параметры*/
	int res=1;
	std::thread th2(hndl_other_func,std::ref(res),8);//если нужно передать ссылку, то ее нужно прятать в std::ref(...) (т.к. параметры передаются всегда по значению)
	th2.join();
	std::cout<<"res = "<<res<<std::endl;	
	
	/*это варианты с лямбда функцией*/
	std::thread th3([](){std::cout<<"Первая лямбда.\n";});
	th3.detach();//не будем ее ждать и она умрет или прервется без помех
	sleep(1);

	int k=0;
	std::thread th4([](int & k, int d){ k+=d;},std::ref(k),2);
	th4.join();
	std::cout<<"Вторая лямбда функция изменила переменную: k = "<<k<<std::endl;
	
	int d=3;
	std::thread th5([d](int & k){ k+=d;},std::ref(k));//переменная d захватывается по значению (в генерируемый функтор на основе описания лямбды)
	th5.join();
	std::cout<<"Третья лямбда функция изменила переменную: k = "<<k<<std::endl;
	

	std::thread th6([&k,d](){ k+=d;});//переменная d захватывается по значению, а k по ссылке (в генерируемый функтор на основе описания лямбды)
	th6.join();
	std::cout<<"Четвертая лямбда функция изменила переменную: k = "<<k<<std::endl;
	return 0;
}
